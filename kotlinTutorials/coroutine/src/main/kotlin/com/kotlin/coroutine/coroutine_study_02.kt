package com.kotlin.coroutine

/**
 *  21 协程
 *  https://www.jianshu.com/p/6e6835573a9c
 *  https://www.bennyhuo.com/2019/04/01/basic-coroutines/
 *  协程是一种非抢占式或协作式的程序并发与调度的框架，协程中的程序可以自动挂起或恢复执行。JVM
 *  中的线程的实现会映射到内核的线程，线程中的代码只有当该线程抢占到cpu时间片才会执行。而
 *  协程的实现不会映射到内核的线程或其他比较重的资源，所以协程相对于线程比较轻量。
 *  22 协程的几种常见实现
 *  22.1 按有无调用栈分类
 *      由于协程支持挂起、恢复，因此挂起点的状态保存极为重要。类似地线程会因CPU的调度权切换
 *  而被中断，它的中断状态会保存在调用栈中，因而协程的实现也按照是否开辟调用栈而分为下面两种
 *  类型。
 *      （1）stackfull coroutine有栈协程；每个协程都会有自己的调用栈，这种情况下的协程实现
 *  很大程度上类似于线程。
 *      （2）stackless coroutine无栈协程；协程没有自己的调用栈，挂起点状态的保持通过状态机
 *  或者闭包等语法来实现。
 *      Kotlin的协程是一种无栈协程，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来
 *  实现，变量保存是通过闭包语法来实现的。不过Kotlin的协程可以在任意层级挂起。
 *  22.2 按调度方式分类
 *      调度过程中，按照转移调度权的目标分为对称协程和非对称协程。
 *      （1）symmetric coroutine对称协程；任何一个协程是相互独立且平等的，调度权可以在任意
 *  协程之间转换。
 *      （2）asymmetric coroutine非对称协程；协程出让调度权的目标只能是它的调用者，即协程
 *  之间有调用和被调用的关系。
 *
 *      不管怎么分类，协程的本质就是程序自己处理挂起和恢复。协程描述了多个程序之间如何出让
 *  运行调度权来完成执行。基于对基本的调度权转移的实现衍生出了各种异步模型，并发模型比如
 *  async/await、channel、Flow等。
 *
 *
 *
 */
